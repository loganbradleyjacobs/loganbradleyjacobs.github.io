---
layout: project
title: "Easy-Get"
date: 2025-10-12
tags: [Reverse Engineering, Crackme, Radare2]
excerpt: "A Crackme I'm attempting to reverse engineer with radare2."
---

## Overview
This is a quick write-up about "Easy-Get", a crackme found on [crackmes.one](https://crackmes.one/).

I started by running the executable, as is typical.
```
> ./LOL
Enter password: 
*password*


```
Okay, so that isn't the password. Let's try a very long password, in case that breaks something.



I first tried to solve this crackme by trying to decompile the executable, as I had done before for less involved problems, using a [decompiler explorer](https://dogbolt.org/). Unfortunately, I got the following message: `Error decompiling: Exceeded time limit`. I hadn't encountered this before, but I had a few ideas of what could be causing this.
1. There is intentional obfuscation. The difficulty of this crackme was a 3.0, which was higher than the others that I had tried. This, and the fact that the executable was stripped of its symbols and debugging information.
2. This is a red herring. Somehow, the user code that was being executed when I ran the file was buried around lots of boilerplate code. 

I had to get some information on the file first, so I ran: `ls -lh LOL` (LOL is the name of the executable... hilarious.) I got the following output:
```
> ls -lh LOL
-rwxrwxr-x@ 1 loganjacobs  staff   420K Jul 21  2018 LOL
```

This told me the executable had full permissions for everyone, only one hard link, that I was the owner, the group was `staff`, the file was 420K kilobytes and that it was created July 21st, 2018.

Aside: after seeing the `@` in the result of `ls`, I decided to see what it meant. Apparently, this means that the file has extended attributes, which are controlled by the `xattr` command. After reading the man page, I found that the file had two extended attributes: com.apple.provenance, and com.apple.quarantine. When I removed com.apple.quarantine from the executable using `xattr -d com.apple.quarantine LOL`, I could run the file without apple's warning that could be unsafe. Finally, a programmatic way to do so!

This `ls` output is all well and good, but I needed to see more about this file and how I can run it, which is a perfect opportunity for the `file` command.
```
> file LOL
LOL: Mach-O 64-bit executable x86_64
```
Interesting. I'm on a M1 Macbook, so it makes sense that I'd be able to run Mach-O executables, especially 64 bit ones. However, the executable is compiled for x86_64 systems, whereas my laptop is an ARM architecture. How was I able to run this executable?
I found the answer: Rosetta 2. Rosetta 2 is a x86 dynamic binary translator. It essentially translates instructions meant for an x86 architecture into ARM instructions that can work on apple's new-ish M-series chips. 

With most of the background knowledge about the file now understood, I could then begin static analysis. I ended up using a tool called [radare2](https://rada.re/n/radare2.html) to analyze the disassembly, but not yet running the program.
Radare2, aka by its alias, r2, is a free and open source reversing toolkit. I was interested in the disassembler, but r2 is a complicated software with many abilities, so I needed to learn about the commands available.
A few tutorials later and I was ready to go.
I started with the following:
```
r2 -e bin.relocs.apply=true -A ./LOL
```
This initializes r2, and does baseline analyzing of imports, entrypoint, symbols, all function agruments, function calls, and others.
I hit `V` to enter visual mode and `p` to go right from a hexdump view to a disassembly view. (`P` will go to the view to the left). I ran a command to list the analyzed functions by hitting `:` and typing `afl` so I could look for functions that could possibly be the entry point. All of the functions had been stripped though, leaving their names as `sym.func.[address]`. One of these functions didn't follow this pattern, though: `entry.init0`. I thought this may be the entry point to the program, so I entered `s entry.init0` to seek to that address, and hit `V` to update visual mode. After a quick analysis, though, it seemed very unlikely that this was the main function.

Below is the entry.init0 function. Column 1 is the address of the instruction. Column 2 is the hex value of the instruction. Column 3 is the disassembly, and Column 4 includes comments to hopefully aid understanding of the disassembly.
```
┌ 73: entry.init0 ();                                                                                                                                                             
│           0x10003cb30      55             push rbp                                                                                                                              
│           0x10003cb31      4889e5         mov rbp, rsp                                                                                                                          
│           0x10003cb34      488d3da57c..   lea rdi, [0x1000547e0]     ; int64_t arg1                                                                                             
│           0x10003cb3b      488d357e5d..   lea rsi, section.12.__DATA.__data    ; 0x1000428c0 ; int64_t arg2                                                                     
│           0x10003cb42      b8ffff0000     mov eax, 0xffff                                                                                                                       
│           0x10003cb47      89c2           mov edx, eax               ; int64_t arg3                                                                                             
│           0x10003cb49      b95d000000     mov ecx, 0x5d              ; ']' ; 93                                                                                                 
│           0x10003cb4e      e88dfeffff     call sym.func.10003c9e0    ;[1] ; sym.func.10003c9e0(0x1000547e0, 0x1000428c0, 0xffff)                                                
│           0x10003cb53      488d3d867c..   lea rdi, [0x1000647e0]     ; int64_t arg1                                                                                             
│           0x10003cb5a      488d355f5d..   lea rsi, [0x1000528c0]     ; int64_t arg2                                                                                             
│           0x10003cb61      b83b1e0000     mov eax, 0x1e3b            ; ';\x1e'                                                                                                  
│           0x10003cb66      89c2           mov edx, eax               ; int64_t arg3                                                                                             
│           0x10003cb68      b947000000     mov ecx, 0x47              ; 'G' ; 71                                                                                                 
│           0x10003cb6d      e86efeffff     call sym.func.10003c9e0    ;[1] ; sym.func.10003c9e0(0x1000647e0, 0x1000528c0, 0x1e3b)                                                
│           0x10003cb72      e809000000     call sym.func.10003cb80    ;[2]                                                                                                       
│           0x10003cb77      5d             pop rbp                                                                                                                               
└           0x10003cb78      c3             ret                                                                                                                                   
            0x10003cb79      0f1f800000..   nop dword [rax
```
We can see that the registers include names like `rbp`, `rdi`, `ecx`, which are x86 registers names. We can also see that the disassembly is in a slightly simplifed AT&T syntax ([Instruction] [Source] [Destination]), as is the radare2 default.

[Link to Crackme](https://crackmes.one/crackme/5b52f6eb33c5d41c0b8ae55f)
