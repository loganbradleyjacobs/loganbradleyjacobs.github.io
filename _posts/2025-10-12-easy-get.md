---
layout: project
title: "Easy-Get"
date: 2025-10-12
tags: [Reverse Engineering, Crackme, Radare2]
excerpt: "A crackme I'm reverse engineering with radare2."
thumbnail: /assets/img/easy-get.png
---

## Overview
This is a quick write-up about "Easy-Get", a crackme found on 
[here.](https://crackmes.one/crackme/5b52f6eb33c5d41c0b8ae55f)


## Background Info

I started by running the executable, as is typical.
```
> ./LOL
Enter password: 
password


```
Okay, so that isn't the password. Let's try a very long password, in case that breaks something.

```
> ./LOL
Enter password: 
121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121212121


```
Okay that's not going to work either. In fact, when I entered 1024 characters (the above is 1023), the program refused to take my output, so perhaps the buffer hehind the scenes is 1024 characters, or there's some variable within the shell that prevents this. Something to keep in mind, but not extraordinarily helpful.

I first tried to solve this crackme by trying to decompile the executable, as I had done before for less involved problems, using a [decompiler explorer](https://dogbolt.org/). Unfortunately, I got the following message: `Error decompiling: Exceeded time limit`. I hadn't encountered this before, but I had a few ideas of what could be causing this.
1. There is intentional obfuscation. The difficulty of this crackme was a 3.0, which was higher than the others that I had tried. This, and the fact that the executable was stripped of its symbols and debugging information, led me to believe obfuscation played a role.
2. This is a red herring. Somehow, the user code that was being executed when I ran the file was buried around lots of boilerplate code. 

I had to get some information on the file first, so I ran: `ls -lh LOL` (LOL is the name of the executable... hilarious.) I got the following output:
```
> ls -lh LOL
-rwxrwxr-x@ 1 loganjacobs  staff   420K Jul 21  2018 LOL
```

This told me the executable had full permissions for everyone, only one hard link, that I was the owner, the group was `staff`, the file was 420K kilobytes and that it was created July 21st, 2018.

Aside: after seeing the `@` in the result of `ls`, I decided to see what it meant. Apparently, this means that the file has extended attributes, which are controlled by the `xattr` command. After reading the man page, I found that the file had two extended attributes: com.apple.provenance, and com.apple.quarantine. When I removed com.apple.quarantine from the executable using `xattr -d com.apple.quarantine ./LOL`, I could run the file without apple's warning that could be unsafe. Finally, a programmatic way to do so!

This `ls` output is all well and good, but I needed to see more about this file and how I can run it, which is a perfect opportunity for the `file` command.
```
> file LOL
LOL: Mach-O 64-bit executable x86_64
```
Interesting. I'm on a M1 Macbook, so it makes sense that I'd be able to run Mach-O executables, especially 64 bit ones. However, the executable is compiled for x86_64 systems, whereas my laptop is an ARM architecture. How was I able to run this executable?

I found the answer: Rosetta 2. Rosetta 2 is a x86 dynamic binary translator. It essentially translates instructions meant for an x86 architecture into ARM instructions that can work on apple's new-ish M-series chips. 

## Static Analysis

With most of the background knowledge about the file now understood, I could then begin static analysis. I ended up using a tool called [radare2](https://rada.re/n/radare2.html) to analyze the disassembly, but not yet running the program.

Radare2, aka by its alias, r2, is a free and open source reversing toolkit. I was interested in the disassembler, but r2 is a complicated software with many abilities, so I needed to learn about the commands available.
A few tutorials later and I was ready to go.
I started with the following:
```
r2 -e bin.relocs.apply=true -A ./LOL
```
This initializes r2, and does baseline analyzing of imports, entrypoint, symbols, all function agruments, function calls, and others.

I hit `V` to enter visual mode and `p` to go right from a hexdump view to a disassembly view. (`P` will go to the view to the left). I ran a command to list the analyzed functions by hitting `:` and typing `afl` so I could look for functions that could possibly be the entry point. All of the functions had been stripped though, leaving their names as `sym.func.[address]`. One of these functions didn't follow this pattern, though: `entry.init0`. I thought this may be the entry point to the program, so I entered `s entry.init0` to seek to that address, and hit `V` to update visual mode. After a quick analysis, though, it seemed very unlikely that this was the main function.

Below is the entry.init0 function. Column 1 is the address of the instruction. Column 2 is the hex value of the instruction. Column 3 is the disassembly, and Column 4 includes comments to hopefully aid understanding of the disassembly.
```
┌ 73: entry.init0 ();                                                                                                                                                             
│           0x10003cb30      55             push rbp                                                                                                                              
│           0x10003cb31      4889e5         mov rbp, rsp                                                                                                                          
│           0x10003cb34      488d3da57c..   lea rdi, [0x1000547e0]     ; int64_t arg1                                                                                             
│           0x10003cb3b      488d357e5d..   lea rsi, section.12.__DATA.__data    ; 0x1000428c0 ; int64_t arg2                                                                     
│           0x10003cb42      b8ffff0000     mov eax, 0xffff                                                                                                                       
│           0x10003cb47      89c2           mov edx, eax               ; int64_t arg3                                                                                             
│           0x10003cb49      b95d000000     mov ecx, 0x5d              ; ']' ; 93                                                                                                 
│           0x10003cb4e      e88dfeffff     call sym.func.10003c9e0    ;[1] ; sym.func.10003c9e0(0x1000547e0, 0x1000428c0, 0xffff)                                                
│           0x10003cb53      488d3d867c..   lea rdi, [0x1000647e0]     ; int64_t arg1                                                                                             
│           0x10003cb5a      488d355f5d..   lea rsi, [0x1000528c0]     ; int64_t arg2                                                                                             
│           0x10003cb61      b83b1e0000     mov eax, 0x1e3b            ; ';\x1e'                                                                                                  
│           0x10003cb66      89c2           mov edx, eax               ; int64_t arg3                                                                                             
│           0x10003cb68      b947000000     mov ecx, 0x47              ; 'G' ; 71                                                                                                 
│           0x10003cb6d      e86efeffff     call sym.func.10003c9e0    ;[1] ; sym.func.10003c9e0(0x1000647e0, 0x1000528c0, 0x1e3b)                                                
│           0x10003cb72      e809000000     call sym.func.10003cb80    ;[2]                                                                                                       
│           0x10003cb77      5d             pop rbp                                                                                                                               
└           0x10003cb78      c3             ret                                                                                                                                   
            0x10003cb79      0f1f800000..   nop dword [rax
```
We can see that the registers include names like `rbp`, `rdi`, `ecx`, which are x86 registers names. We can also see that the disassembly is in a slightly simplifed Intel syntax ([Instruction] [Destination] [Source]), as is the radare2 default.

There are a few giveaways that this is not our user code. The first two instructions are `push rbp` and `mov rbp, rsp` which are typical of compilers setting up a stack frame. `lea` is used for simple address loading, and the addresses themselves are meaningless, whereas a user would use labels. These could be artifacts from the executable being stripped though. The biggest tell that this is not a user function is the last instruction: `nop dword [rax]`. This instruction, being a `nop` (short for no-operation), doesn't do anything. Compilers will insert these instrtuctions into functions to align them to a 16 byte boundary for performance reasons. A user would almost never do this, and if they wanted to use a `nop`, they would just use a single-byte version.

Okay, so this isn't our user code. Perhaps if we follow some of the called functions, we can track it down? I scrolled down to the first function call `call sym.func.10003c9e0` and hit `enter` to see that function. 
```
; XREFS: CALL 0x10003b0d3  CALL 0x10003b5b5  CALL 0x10003b6fd  CALL 0x10003c92d  CALL 0x10003cb4e     
            ; XREFS: CALL 0x10003cb6d                                                                             
┌ 70: sym.func.10003c9e0 (int64_t arg1, int64_t arg2, int64_t arg3);                                              
│ `- args(rdi, rsi, rdx)                                                                                          
│           0x10003c9e0      4157           push r15                                                              
│           0x10003c9e2      4156           push r14                   ; mach0_segment64_0                        
│           0x10003c9e4      4155           push r13                                                              
│           0x10003c9e6      4154           push r12                                                              
│           0x10003c9e8      53             push rbx                                                              
│           0x10003c9e9      88c8           mov al, cl                                                            
│           0x10003c9eb      4989f8         mov r8, rdi                ; arg1                                     
│           0x10003c9ee      4989f1         mov r9, rsi                ; arg2                                     
│           0x10003c9f1      4885d2         test rdx, rdx              ; arg3                                     
│           0x10003c9f4      4c8d152b01..   lea r10, [0x10003cb26]                                                
│           0x10003c9fb      4c8d1d2400..   lea r11, [0x10003ca26]                                                
│           0x10003ca02      4d0f44da       cmove r11, r10                                                        
│           0x10003ca06      48897424f8     mov qword [rsp - 8], rsi    ; arg2                                    
│           0x10003ca0b      884424f7       mov byte [rsp - 9], al                                                
│           0x10003ca0f      48895424e8     mov qword [rsp - 0x18], rdx    ; arg3                                 
│           0x10003ca14      48897c24e0     mov qword [rsp - 0x20], rdi    ; arg1                                 
│           0x10003ca19      4c894424d8     mov qword [rsp - 0x28], r8                                            
│           0x10003ca1e      4c894c24d0     mov qword [rsp - 0x30], r9                                            
└           0x10003ca23      41ffe3         jmp r11                                                               
            ; DATA XREF from sym.func.10003c9e0 @ 0x10003c9fb(r)                                                  
            0x10003ca26      8a4424f7       mov al, byte [rsp - 9]                                                
            0x10003ca2a      c0e804         shr al, 4                                                             
            0x10003ca2d      8a4c24f7       mov cl, byte [rsp - 9]                                                
            0x10003ca31      30c1           xor cl, al
and so on...            
```
This function is a bit odd for two reasons.
1. It's called in many places. The `XREFS:` at the top reveals this function is called in 6 different places. This isn't necessarily odd on its own, but it doesn't seem to be doing much, which leads me to the other reason.
2. This function doesn't have a return statement, and in fact ends in an indirect jump. Also, the functionality above that last `jmp` instruction loads two addresses into `r10` and `r11`, and depending on the result of `test rdx, rdx`, may move `r10` into `r11` if the zero flag is set, which it should be if rdx = rdx, which it does...

At this point, I realized that this was not the user code, and was probably somewhat obfuscated. I followed some of the addresses it could have indirectly jumped to, but to make a long story short, they were not leading to the user code. This was already harder than the crackmes I had done beforehand. Finding the user code there was not a challenge. Perhaps this redirection was what was causing the decompiler explorer to time out.

If the user code isn't in the disassembly, then where is it? Perhaps it loads it from memory. I couldn't run the executable within the r2 debugger at the moment, so I tried looking at any strings in the data section with `rabin2 -z ./LOL` I was returned a list of strings, much of which was gibberish, but much of which was English that I could read. A lead!

I came across this line in the output:
```
238 0x0003e201 0x10003e201 27  28   4.__TEXT.__cstring ascii   cannot number coerce Symbol
```
This seemed odd, if this is just C code like I thought, then there shouldn't be coercing. I had seen a video a couple days before in which the creator was explaining why people dislike Javascript, and one of the reasons was type coercion (the reason why in Javascript, "2" + 2 = "22".) I looked this line up, and sure enough, the results were about type coercion in Javascript. 

I then turned my attention to the `*.c` files that kept cropping up in the `rabin2 -z ./LOL` output. I took one, `duk_bi_thrower.c`, and typed that into my browser as well. I was brought to a github page for "Duktape", an embeddable Javascript engine. This engine is used to embed ECMAScript (Javascript) into C programs, so that higher-level scripting can be done in Javascript, while tasks that take low-level control can be written in C if needed. In this case, it seems that the actual user code is written in Javascript, and the disassembly I was seeing was the Duktape boilerplate. That explains why I couldn't find the user code!


